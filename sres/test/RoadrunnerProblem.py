import numpy as np
import tellurium as te
from sres import SRES
from tellurium.roadrunner.extended_roadrunner import ExtendedRoadRunner


###################################################################################3
#   highjacking telluriums interface to roadrunner
#

def freeParameters(self):
    """
    Roadrunner models do not have a concept of "free" or "fixed"
    parameters (maybe it should?). Either way, we add a cheeky method
    to the tellurium interface to roadrunner to return the names
    of the parameters we want to fit
    """
    return ["k1", "k2"]

# assign, and now freeParameters is callable bound to ExtendedRoadrunner types
ExtendedRoadRunner.freeParameters = freeParameters

#####################################################################################3
#   model and data generation
#

# globally scoped model
r = te.loada("""
   S1 -> S2; k1*S1;
   S2 -> S3; k2*S2;
   S1 = 1; S2 = 0; S3 = 0;
   k1 = 0.15; k2 = 0.45;
""")

# Simulate "experimental" data
m = r.simulate(0, 20, 21)

# We'll just create noise data for S2
x_data = m['time']
y_data = m['[S2]']

for i in range(0, len(y_data)):
    # Add random noise to synthetic data
    t = np.random.normal(0, 0.05)
    y_data[i] = y_data[i] + t


##############################################################
#   Configure the optimization
#

@SRES.COST_FUNCTION_CALLBACK
def cost_fun(parameters, fitness, constraints):
    """
    Brief
    -----
    Compute difference between experimental dataset and model simulation with candidate parameters.
    This cost function is user defined and used as input to the main SRES algorithm. The input
    to this function is always [parameters, fitness and constraints]. You do not need to worry
    about generating candidate parameters as they are generated by the underlying algorithm. You do
    however have to worry about updating the fitness value, which you do like this:

        fitness.contents.value = calculated_cost

    Where calculated_cost is a float computed by your function. Note, that even though
    we haven't used the constraints argument in this cost function, we still need to pass it in
    as an input parameter.

    Details
    -------
    The underlying SRES C code requires as input a function pointer to a cost function
    that has the following signature:

        typedef void(*ESfcnFG)(double *, double *, double *);

    We can create a cost function in Python to pass to C by using the
    :py:class:`SRES.COST_FUNCTION_CALLBACK` decorator. Since the C end is
    expecting a function with three double pointer types, we must have
    as arguments to our cost function, three arguments.

    When coding the cost function, you need to remember that the types of
    parameter, fitness and constraints are ctypes pointers to double
    arrays in the case of the parameter and constraints argument and
    a pointer to a double in the case of fitness. To do computation
    with these types you need the value that the pointer points to, not
    the pointer. To get these, you use:
        >>> parameters.contents[0]
    In the case of pointer to a double array or
        >>> fitness.contents.value
    in the case of a pointer to a double.

    Args
    ----
    parameters: A list of candidate parameters with the same size as the
                dimensionality of your defined optimization problem.
    fitness:    This is the value that you must compute and assign.

    """
    # important for roadrunner: simulation data are persistent. Therefore
    # we reset the model before every simulation
    r.reset()

    # set the new parameter values
    for i in range(len(parameters.contents)):
        param = r.freeParameters()[i]
        val = parameters.contents[i]
        setattr(r, param, val)

    # compute cost
    sim = r.simulate(0, 20, 21, ["S2"]) # note, same size as experimental data
    cost = 0
    for i in range(y_data.shape[0]):
        cost += (y_data[i] - sim[i]) ** 2

    # update fitness. This step is crucial and evey cost function
    # must have this line
    fitness.contents.value = cost



sres = SRES(
    cost_function=cost_fun,
    ngen=20,
    lb=[0.01]*2,
    ub=[10]*2,
    parent_popsize=1000,
    child_popsize=1000,
)
sres.fit()



param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']},
  {'C': [1, 10, 100, 1000], 'gamma': [0.001, 0.0001], 'kernel': ['rbf']},
 ]







#
# guess = [0.2, 0.3]  # initial guess for params
# p, cov, infodict, mesg, ier = optimize.leastsq(f_resid, guess, full_output=True)
# r.resetAll()
# print("Parameter values are ", p, "Diff = ", p[0] - r.k1, p[1] - r.k2)
# print(mesg)
# print(cov)
# r.reset()
# for i in range(0, nParameters):
#     r.model[toFit[i]] = p[i]
# m = r.simulate(0, 20, 100, ['time', 'S1', 'S2', 'S3'])
# plt.plot(x_data, y_data, 'sr')
# plt.plot(m[:, 0], m[:, 1], '-b')
# plt.plot(m[:, 0], m[:, 2], '-b')
# plt.plot(m[:, 0], m[:, 3], '-b')
# plt.xlabel('Time', {"fontsize": 16})
# plt.ylabel("Concentration, S2", {"fontsize": 16})
# plt.legend(('data', 'fit'), loc=0)
# plt.show()
